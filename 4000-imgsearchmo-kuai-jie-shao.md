#imgSearch 

##0.概述

本文是个人开源项目 ImgSearch 的产出，各个模块遇到的问题及优化策略和一些较重要的算法。



##1.图片下载与读取

### 1.0 下载

为效率计，采用并行的下载方式，同样地，为以后并行读取、处理作准备，需要考虑图片存储方式

###1.1 存库设计

- 为高效的存储和读取，摒弃一些不必要的功能，采用的库是 leveldb 这样一个键值对小型数据库 (项目中后期遇到了读取效率问题， 作了较多的优化考虑。反思：**leveldb 可能不太适合此项目的一次写多次读的场景**) 

- 图片库的键是图片名字，值是图片源数据。为后续并行处理，图片名的设计为线程 id + seqence number. 又为了显示方便，线程 id 设置为 A, B, C...，图片名格式为：A0000001。存储空间上，图片名占 4 个字节。逻辑上，每个线程可存储最多 1000 万个图片：这已经足够了，进一步地通过分库可作横向无限扩充。并行下载，并行存储，多个线程并行写入，这是 leveldb 的强项。


###1.2 性能考虑

读库时遇到了以下性能问题：

- 读库模式是：各线程通过 id 定位到各线程处理点，往后遍历：线程 A 处理 A......，线程 B 处理 B.....
- 性能问题：上面读库模式需要结合读取方式和 leveldb 的设计来考虑，为什么会发生读取速度慢的问题：直观感受是，16 个 go routine 并行并未占满 CPU，使用率只占到 30%：使用率应该是接近于 100%，因为取出数据后所有工作都是 cpu 计算。
- 优化：首先，各线程使用 DB::Iterator 顺序访问，由于是逻辑层的顺序，而非物理存储层面的顺序：若每相领两个图片所在的 leveldb::block 都不同，这意味着 leveldb 每次都需要切换 block 读：最直接地，block cache 会被换入后，读取一个键，再换出，不停重复这个过程。其次，由于写库时多个线程同时写，因此无法保障各线程物理存储层面的有序性。基于以上两点，优化写入模式为：各线程使用一个缓存，蓄满后转化为 Batch 一次性写入。然而很遗憾的是，这并没有多少改善， CPU 使用率仍然为 30 %。
- 进一步优化：复盘上面的模型，难道问题出现在，leveldb::Batch 写入，并不能保证各线程的数据在相同的 block？确实：由于 leveldb 没有事务的概念，并不能保证一个线程的 Batch  在写入的块，不被另一个线程的 Batch 写入插入打乱。因此，我们需要进一步地优化：同一时间，只能有一个 goroutine 写入。我们增加一个二级缓存，接收各线程的一级缓存数据，若一级缓存满了则加入二级缓存(加锁)，若二级缓存满了则入库。我们将二级缓存设置的大一些就能减少线程的等待时间(因为 leveldb 写入速度远快于处理速度, 故等待时间忽略不计)。再次很遗憾，还是没有多少改善。
- 更进一步：经过上面的优化，我们应该可以肯定各线程的数据确实在同一个物理 block 里面。因此，读取效率低的原因就隐藏在 leveldb 怎么处理同一个块中数据的读取上。深入 leveldb ：iterator 顺序遍历涉及到这几个内部迭代器: tablecache,  memtable, immtable。tablecache 包装了各第0层文件的迭代器和其它层次各层的迭代器，它们内部会读写一个全局的 blockcache：它正是关键点：若 blockcache 大小设置的小于 n 个线程所需要的大小则会导致多个线程同时竞争这个 blockcache: 各线程换入的缓存可能立即会被其它线程换出，相互掣肘导致所有线程读取效率低。知道了这一点，n 个 goroutine 场景下，我们将 leveldb 的 blockCacheSize 设置为 (n+1)*blockSize，多设置一个 blockSize 以应对余数或其它边边角角。经过这一次优化， CPU 使用率如期升到了 100%

##X.图片处理

最初的想法是传统的想法，识别出文字，与图片关联。

###kemans

运用 kmenas 算法，识别文字

- 1.根据汉字在图片中的规律，使用窗口扫描灰度化后的图片，若这个窗口内含有的像素点超过一定的数目则这个窗口中心可以成为一个中心
- 若参加聚类的像素点数目存在量级差别，则不是一张图？
- 如果初始的质心有较大不同，则说明两个文字有较大可能不同？



### 汉字特征提取

- 只识别其中一个字，就可以识别整个词语?
- ​



### 图片修复

预期是 jpeg 文件，通过判断文件魔数(起始两个字节)，发现确实是 0xFFD8。最后两个字节是 0xFFD9。它们是 jpeg 的标准。然而在使用 imgo 库读取图片内容时，发现读取失败: invalid marker。具体也不报说是哪个 marker  有误。尝试使用 java 的 jpeg 库读取：不同图片报出来的 invalid marker 后附加的数字不一样，猜测应该是在某些标记处的值不符合预期。

因此需要了解 jpeg 图片的基本格式:
![](/assets/imgSearch/jpeg_marker.png)

很明显，当 jpeg 二进制数据 0xFF 后若跟了非标准的字节则会被算作无效 marker。
具体如下：
1)非法的 markder，根据 image.jpeg 库的 reader.go 中描述的 markder，无效的 marker 均小于 C0
2)Corrupt JPEG data: 'n' extraneous bytes before marker 0xd9 ，意思是说marker: 0xd9 的前面有 n 个多余的字节
经过排查，发现 1) 会导致解析错误，而 2) 只是一个告警，不会报错。所以我们的解决办法即是删除不合法的 marker 的第一个字节：0xFF
image.jpeg/reader.go 文件关键位置：
![](/assets/imgSearch/jpeg_golang_marker_code.png)

